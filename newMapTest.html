<!DOCTYPE html>
<style>
  body,
  html {
    overflow: hidden;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
  }

  #mapContainer {
    background-color: #000;
    opacity: 0.6;
    transition: all 0.5s ease;
    position: fixed;
    width: 25%;
    height: calc(25% * 16 / 9);
    right: 0;
    bottom: 0;
    margin: 1rem;
    border-radius: 1rem;
    border-color: #000;
    border-style: solid;
    border-width: 1rem;
    display: flex;
    flex-direction: column;
    align-items: end;
  }

  #mapContainer:hover {
    opacity: 0.9;
    width: 45%;
    height: calc(40% * 16 / 9);
  }
</style>

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="shortcut icon" href="images/favicon.png" type="image/x-icon" />
    <title>Document</title>
  </head>
  <body>
    <div id="mapContainer"></div>

    <script>
      class LocationSelectorMapCanvas {
        constructor({
          container,
          imageUrl,
          onSelect,
          bgColor = "#FFFFFF",
          markerImgURL = null,
        }) {
          this.container = container;
          this.imageUrl = imageUrl;
          this.onSelect = onSelect || (() => {});
          this.markerImg;
          if (markerImgURL) {
            this.markerImg = new Image();
            this.markerImg.src = markerImgURL;
          }

          this.canvas = document.createElement("canvas");
          this.canvas.style.width = "100%";
          this.canvas.style.height = "100%";
          this.canvas.style.touchAction = "none";
          this.container.appendChild(this.canvas);
          this.ctx = this.canvas.getContext("2d");
          this.bgColor = bgColor;

          this.marker = null; // { x, y }
          this.offsetX = 0;
          this.offsetY = 0;
          this.scale = 1;
          this.minScale = 0.1;
          this.maxScale = 6;

          this._setupEvents();

          this.image = new Image();
          this.image.onload = () => {
            this._resizeCanvas();
            this._draw();
            this.offsetX = -this.image.width / 2;
            this.offsetY = -this.image.height / 2;
          };
          this.image.src = imageUrl;

          window.addEventListener("resize", () => {
            this._resizeCanvas();
            this._draw();
          });

          this._resizeObserver = new ResizeObserver(() => {
            this._resizeCanvas();
          });
          this._resizeObserver.observe(this.container);
          this._draw();
        }

        _resizeCanvas() {
          this.canvas.width = this.container.clientWidth;
          this.canvas.height = this.container.clientHeight;
          this._draw();
        }

        _setupEvents() {
          let isDragging = false;
          let dragThresholdPassed = false;
          let startX = 0;
          let startY = 0;
          let lastX = 0;
          let lastY = 0;

          this.canvas.addEventListener("pointerdown", (e) => {
            isDragging = true;
            dragThresholdPassed = false;
            startX = lastX = e.clientX;
            startY = lastY = e.clientY;
            this.canvas.setPointerCapture(e.pointerId);
          });

          this.canvas.addEventListener("pointermove", (e) => {
            if (!isDragging) return;

            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;

            // If drag threshold hasn't passed yet, check total movement from start
            if (!dragThresholdPassed) {
              const totalDx = e.clientX - startX;
              const totalDy = e.clientY - startY;
              if (Math.hypot(totalDx, totalDy) > 4) {
                dragThresholdPassed = true;
              }
            }

            if (dragThresholdPassed) {
              this.offsetX += dx;
              this.offsetY += dy;
              this._draw();
            }

            lastX = e.clientX;
            lastY = e.clientY;
          });

          this.canvas.addEventListener("pointerup", (e) => {
            if (!dragThresholdPassed) {
              // Only set marker if we weren't dragging
              const rect = this.canvas.getBoundingClientRect();
              const canvasX = e.clientX - rect.left;
              const canvasY = e.clientY - rect.top;

              const x = (canvasX - this.offsetX) / this.scale;
              const y = (canvasY - this.offsetY) / this.scale;

              this.setCoords(x, y);
              this.onSelect(Math.round(x), Math.round(y));
            }

            isDragging = false;
            dragThresholdPassed = false;
            this.canvas.releasePointerCapture(e.pointerId);
          });

          this.canvas.addEventListener("pointercancel", (e) => {
            isDragging = false;
            dragThresholdPassed = false;
            this.canvas.releasePointerCapture(e.pointerId);
          });
          this.canvas.addEventListener(
            "wheel",
            (e) => {
              e.preventDefault();

              const zoomFactor = 1.1;
              const rect = this.canvas.getBoundingClientRect();

              // Get mouse position relative to canvas
              const mouseX = e.clientX - rect.left;
              const mouseY = e.clientY - rect.top;

              // Get coordinates before zoom
              const worldX = (mouseX - this.offsetX) / this.scale;
              const worldY = (mouseY - this.offsetY) / this.scale;

              // Zoom in or out
              if (e.deltaY < 0) {
                this._setScale(this.scale * zoomFactor);
              } else {
                this._setScale(this.scale / zoomFactor);
              }

              // Adjust offset to zoom around mouse position
              this.offsetX = mouseX - worldX * this.scale;
              this.offsetY = mouseY - worldY * this.scale;

              this._draw();
            },
            { passive: false }
          );
        }

        _setScale(newScale) {
          if (newScale > this.maxScale) {
            this.scale = this.maxScale;
            return;
          }
          if (newScale < this.minScale) {
            this.scale = this.minScale;
            return;
          }
          this.scale = newScale;
        }

        _touchDist(e) {
          const [t1, t2] = e.touches;
          return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        }

        _draw() {
          if (!this.image.complete) return;

          const ctx = this.ctx;
          ctx.fillStyle = this.bgColor;
          ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          ctx.save();
          ctx.translate(this.offsetX, this.offsetY);
          ctx.scale(this.scale, this.scale);
          ctx.drawImage(this.image, 0, 0);
          if (this.marker) {
            if (this.markerImg !== null) {
              ctx.drawImage(
                this.markerImg,
                this.marker.x - this.markerImg.width / 2,
                this.marker.y - this.markerImg.height / 2
              );
            } else {
              ctx.beginPath();
              ctx.arc(this.marker.x, this.marker.y, 5, 0, 2 * Math.PI);
              ctx.fillStyle = "red";
              ctx.strokeStyle = "white";
              ctx.lineWidth = 1 / this.scale;
              ctx.fill();
              ctx.stroke();
            }
          }
          ctx.restore();
        }

        setCoords(x, y) {
          this.marker = { x, y };
          this._draw();
        }

        getCoords() {
          return this.marker
            ? { x: Math.round(this.marker.x), y: Math.round(this.marker.y) }
            : null;
        }

        clear() {
          this.marker = null;
          this._draw();
        }
      }

      const map = new LocationSelectorMapCanvas({
        container: document.getElementById("mapContainer"),
        imageUrl: "images/map.png",
        onSelect: (x, y) => {
          console.log("Selected:", x, y);
        },
        bgColor: "#000000",
        markerImgURL: "images/knightPin.png",
      });

      // set a marker
      map.setCoords(1024, 768);

      // get selected location
      const coords = map.getCoords(); // {x,y}
    </script>
  </body>
</html>
